var C=Object.defineProperty;var v=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var D=(a,n,e)=>n in a?C(a,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[n]=e,_=(a,n)=>{for(var e in n||(n={}))P.call(n,e)&&D(a,e,n[e]);if(v)for(var e of v(n))x.call(n,e)&&D(a,e,n[e]);return a};import{k as O,l as c,m as w,o as A,p as g,w as R,q as z,s as B}from"./entry-48deebdc.mjs";const M=a=>O(a)?a:c(a),E=()=>null;function N(a,n,e={}){var d,h,m,y,p;if(typeof a!="string")throw new TypeError("asyncData key must be a string");if(typeof n!="function")throw new TypeError("asyncData handler must be a function");e=_({server:!0,default:E},e),e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(h=(d=e.lazy)!=null?d:e.defer)!=null?h:!1,e.initialCache=(m=e.initialCache)!=null?m:!0;const r=w(),i=z();if(i&&!i._nuxtOnBeforeMountCbs){const f=i._nuxtOnBeforeMountCbs=[];i&&(A(()=>{f.forEach(s=>{s()}),f.splice(0,f.length)}),g(()=>f.splice(0,f.length)))}const l=()=>e.initialCache&&r.payload.data[a]!==void 0,t={data:M((y=r.payload.data[a])!=null?y:e.default()),pending:c(!l()),error:c((p=r.payload._errors[a])!=null?p:null)};t.refresh=(f={})=>r._asyncDataPromises[a]?r._asyncDataPromises[a]:f._initial&&l()?r.payload.data[a]:(t.pending.value=!0,r._asyncDataPromises[a]=Promise.resolve(n(r)).then(s=>{e.transform&&(s=e.transform(s)),e.pick&&(s=H(s,e.pick)),t.data.value=s,t.error.value=null}).catch(s=>{t.error.value=s,t.data.value=B(e.default())}).finally(()=>{t.pending.value=!1,r.payload.data[a]=t.data.value,t.error.value&&(r.payload._errors[a]=!0),delete r._asyncDataPromises[a]}),r._asyncDataPromises[a]);const u=()=>t.refresh({_initial:!0}),b=e.server!==!1&&r.payload.serverRendered;{b&&r.isHydrating&&a in r.payload.data?t.pending.value=!1:i&&r.payload.serverRendered&&(r.isHydrating||e.lazy)?i._nuxtOnBeforeMountCbs.push(u):u(),e.watch&&R(e.watch,()=>t.refresh());const f=r.hook("app:data:refresh",s=>{if(!s||s.includes(a))return t.refresh()});i&&g(f)}const o=Promise.resolve(r._asyncDataPromises[a]).then(()=>t);return Object.assign(o,t),o}function S(a){const n=a?Array.isArray(a)?a:[a]:void 0;return w().callHook("app:data:refresh",n)}function H(a,n){const e={};for(const r of n)e[r]=a[r];return e}export{S as r,N as u,M as w};
